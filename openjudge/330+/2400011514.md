# 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/48381897/)

```
基本信息
#: 48381897
题目: P1400
提交人: 谢冰2400011514(xb谢神)
内存: 3848kB
时间: 59ms
语言: Python3
提交时间: 2025-02-27 18:53:22
```

这个问题可以通过贪心算法来解决。我们需要尽量少地安装雷达，每个雷达的覆盖半径为 `d`。雷达安装在海岸线上，所以我们需要找出每个岛屿的 x 坐标距离海岸线的距离，并尽量覆盖最多的岛屿。

### 思路：
1. **计算岛屿的覆盖范围**：对于每个岛屿，给定其位置 `(x, y)`，雷达可以覆盖的最远的 x 坐标范围是 `x ± d`，因为雷达的覆盖是一个圆形。
2. **排序**：首先按岛屿的 x 坐标排序。接着，使用贪心算法尽量减少安装雷达的数量，具体做法是：
   - 从左到右遍历岛屿，寻找一个雷达安装位置，尽量覆盖更多的岛屿。
   - 安装一个雷达后，跳过所有被该雷达覆盖的岛屿，继续处理下一个未被覆盖的岛屿。

3. **检查是否有解**：如果某个岛屿无法被任何雷达覆盖，则该测试用例返回 `-1`。

### 代码解释：
1. **`solve_case`** 函数：
   - 对于每个岛屿，计算其在海岸线的覆盖范围，并将其作为 `(min_x, max_x)` 的形式存储在 `ranges` 列表中。
   - 如果一个岛屿超出了雷达的覆盖范围（即 `y` 大于 `d`），立即返回 `-1`。
   - 然后对 `ranges` 列表按最大覆盖 `max_x` 排序，以便使用贪心算法，尽量减少雷达数量。
   - 使用一个变量 `last_installed_radar` 来记录上一个雷达的安装位置，每当遇到无法被当前雷达覆盖的岛屿时，就安装一个新的雷达，并更新 `last_installed_radar`。

2. **`main`** 函数：
   - 逐个处理测试用例，读取输入数据并调用 `solve_case`。
   - 输出每个测试用例的结果。

### 样例测试：

输入：
```
3 2
1 2
-3 1
2 1

1 2
0 2

0 0
```

输出：
```
Case 1: 2
Case 2: 1
```

### 时间复杂度：
- 对于每个测试用例，排序的时间复杂度是 `O(n log n)`，遍历岛屿的时间复杂度是 `O(n)`。因此，总的时间复杂度是 `O(n log n)`，适合处理最多1000个岛屿的情况。

希望这个实现对你有所帮助！如果有问题或需要进一步优化，随时告诉我！